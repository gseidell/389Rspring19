# Writeup 3 - Operational Security and Social Engineering

Name: Glenn Seidell
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examniation.

Digital acknowledgement: Glenn Seidell

## Assignment Writeup

### Part 1 (40 pts)

The flag can be obtained after nc'ing by simply entering "hack; cat /home/flag.txt"
Without knowing where the flag is you can also obtain a shell and just do some digging. If you are short on time you can use "ls -la * | grep -i flag -C 5". This will search 1 level deep in all of the root folders and in this case reveals a file called flag.txt in the /home folder quite quickly. 
CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}

Inputting "google.com; ls" after nc'ing into the server results in the dns information bing dumped as well as the current directory listing. This tells us that the server is vulnerable and is just blindly running our input after dropping a command in front. If we are a little more malicious and put /bin/bash after the semicolon we can trick the server into giving us a shell. This gives us a tremendous ammount of control over the machine. We can cd through all of their directories and view all of their files including /etc/os-release to get a bunch of info about the operating system, /proc/cpuinfo to get a bunch of info about the cpu and its vulnerablities (bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf) and of course /home/flag.txt. Since we know that the server is just running dig commands, running "ls -la * | grep -i dig -C 5" is worth a shot. It will look through the first level of all of the root directories and see if it has any files with dig in their names. The -C 5 will hopefully give us enough context to  It gives :
ls -la * | grep -i dig -C 5

opt:
total 12
drwxr-xr-x 1 root root 4096 Mar  2 20:38 .
drwxr-xr-x 1 root root 4096 Mar  8 22:23 ..
-rwxr-xr-x 1 root root   73 Mar  2 20:38 .dig.sh

proc:
total 4
dr-xr-xr-x 417 root root    0 Mar  8 22:23 .
drwxr-xr-x   1 root root 4096 Mar  8 22:23 ..

We can now cat /opt/.dig.sh to look for more potential vulnerabilities. This confirms our suspicion that it is just evaluating anything we give it without any sanitization. The owner of the server could definitely improve this by simply removing semicolons from the input. This would prevent input as simple as "im in; /bin/bash" from giving any idiot a shell on your server.


### Part 2 (60 pts)

To scriptify this vulnerablity, I wrote a script that takes user input and sends it to the socket when necesary and prints the response. It also abstracts away the actual code injection attack into the single "shell" command. I initially had trouble with recieving from the socket after every commmand because not every command has ouptut. This was causing simple cd commands to hang the whole script as the recv line was blocking while waiting for a response that was never going to come. I intially got around this with an if statement that just hardcoded skipping the recv if the command had "cd" in it somewhere. I was able to implement a more permenant solution with select. With this I was able to check if the socket had any thing to give to me before deciding to read from it thus solving my indefinite blocking issue. I implemented the pull feature with scp allowing users to remotely copy files between servers. When they want to exit I simply close the socket and exit the script. This is much more graceful than control c'ing the nc and getting the keyboard interrupt error message.


